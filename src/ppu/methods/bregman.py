"""Module with Bregman Information implementation.

Based on:
Uncertainty Estimates of Predictions via a General Bias-Variance Decomposition
Sebastian G. Gruber and Florian Buettner
"""

import numpy as np
from sklearn.inspection._plot.decision_boundary import _check_boundary_response_method

from ppu.methods.utils import LSE, LSE_LB_estimator_, stable_logit_transform

"""
This function is adapted from the following source:

Source: https://github.com/MLO-lab/Uncertainty_Estimates_via_BVD.git
Author: SebGGruber
License: MIT License
"""
def BI_LSE(z, bound="auto", C=1000):
    r"""Bregman information generated by LSE(x) = ln(1 + \sum_i e^{x_i})
    `bound`={'auto', 'lower', 'upper'} sets if upper or lower bound should be estimated;
    'upper' is only possible for the binary setting;
    'auto' selects 'upper' for binary and 'lower' for non-binary data;
    input: reduced logits
    """
    if len(z.shape) < 2:
        z = np.expand_dims(z, axis=1)

    if bound=="auto":
        # avg = np.mean(z)
        # xxT = np.outer(z, z)
        # avg_sq = np.mean(xxT)*n/(n-1) - np.mean(np.diag(xxT))/(n-1)
        # # if False, we would get log of a negative value
        # log_of_pos = 0 < (1 + (np.mean(z)**2 - np.var(z)/n)/(16*np.pi**2))
        log_of_pos = True
        upper_valid = (z.shape[1]==1) and log_of_pos
        bound = "upper" if upper_valid else "lower"

    E_of_LSE = np.mean(LSE(z))

    if bound=="upper":
        LSE_of_E = LSE_LB_estimator_(z, C)
    elif bound=="lower":
        avg_z = np.mean(z, axis=0)
        LSE_of_E = LSE(np.expand_dims(avg_z, axis=0))[0]
    else:
        raise NotImplementedError

    return E_of_LSE - LSE_of_E


def get_BI(xs, models):
    preds = np.array([_check_boundary_response_method(m, "predict_proba")(xs) for m in models])
    # preds are probabilities
    if len(preds.shape) == 3:
        preds = preds[:,:,1]

    logits = stable_logit_transform(preds)

    return np.array([BI_LSE(zs, bound="lower") for zs in logits.T])

def get_revised_BI(xs, models):
    preds = np.array([_check_boundary_response_method(m, "auto")(xs) for m in models])
    # preds are probabilities
    if len(preds.shape) == 3:
        preds = preds[:,:,1]

    logits = stable_logit_transform(preds)

    return np.array([BI_LSE(zs, bound="lower") / abs(b.mean() - 0.5) for b,zs in zip(preds.T, logits.T)])

